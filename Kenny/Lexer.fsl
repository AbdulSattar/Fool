{
module Lexer
open System
open Parser
open Microsoft.FSharp.Text.Lexing

let lexeme = LexBuffer<char>.LexemeString
}

// These are some regular expression definitions
let digit = ['0'-'9']
let alpha = ['a'-'z' 'A'-'Z']
let ident = alpha (alpha | digit)*
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')
let comment = "//" [^'\r' '\n']*
let char = "'" ( "\\n" | "\\a" | "\\t" | "\\r" | "\\\\" | "\\'" | [^ '\'']) "'"

rule tokenize = parse
| whitespace     { tokenize lexbuf }
| newline        { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf }
| comment        { tokenize lexbuf }
| '\"'           {
                     let sb = new System.Text.StringBuilder()
                     STRINGLIT (string sb lexbuf)
                 }
// Types
| "int"    { INTTYPE }
| "float"  { FLOATTYPE }
| "char"   { CHARTYPE }
| "string" { STRINGTYPE }
| "bool"   { BOOLTYPE }

//Keywords
| "if"           { IF }
| "else"         { ELSE }
| "while"        { WHILE }
| "for"          { FOR }
| "to"           { TO }
| "downto"       { DOWNTO }
| "read"         { READ }
| "write"        { WRITE }

// Reserved Words
| "true"         { TRUE }
| "false"        { FALSE }

// Identifiers
| ident          { IDENT (lexeme lexbuf) }

// Misc
| '('            { OPAREN }
| ')'            { CPAREN }
| '{'            { OBLOCK }
| '}'            { CBLOCK }
| ';'            { DELIM }
| ','            { COMMA }
// Assign
| '='            { ASSIGN }
// ArithOp
| '+'            { PLUS }
| '-'            { MINUS }
| '*'            { TIMES }
| '/'            { DIVIDE }
//RelOp
| ">="          { GTE }
| "<="          { LTE }
| "=="          { EQ }
| "!="          { NEQ }
| '>'           { GT }
| '<'           { LT }
// Numbers
| digit+                                     { INTLIT (Int32.Parse(lexeme lexbuf)) }
| digit+ '.' ((digit+) (['e' 'E'] digit+)?)? { FLOATLIT (Convert.ToDouble(lexeme lexbuf)) }
// Chars
| char          { CHARLIT ((lexeme lexbuf).[1]) }
// EOF
| eof   { EOF }

and string s = parse
| "\\n"            { s.Append('\n') |> ignore; string s lexbuf }
| "\\r"            { s.Append('\r') |> ignore; string s lexbuf }
| "\\t"            { s.Append('\t') |> ignore; string s lexbuf }
| "\\a"            { s.Append('\a') |> ignore; string s lexbuf }
| "\\\""           { s.Append('\"') |> ignore; string s lexbuf }
| "\\\\"           { s.Append('\\') |> ignore; string s lexbuf }
| '\"'             { s.ToString() }
| eof              { failwithf "Incomplete string" }
| _                { s.Append(lexeme lexbuf) |> ignore; string s lexbuf }